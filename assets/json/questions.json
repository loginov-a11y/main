[
  {
    "tag": "architecture",
    "name": "Архитектура js",
    "list": [
      {
        "question": "Feature sliced design или FSD архитектура - что это",
        "answer": "Архитектурная методология для front-end проектов, разработанная в 2021 году  Суть подхода:  Доменный подход, деление на слои, сегменты, изолированные модули, правила по по работе между слоями (чтобы не возникали циклические зависимости), продуктовая составляющая (features) и многое другое."
      },
      {
        "question": "Domain Driven Design или DDD архитектура - что это",
        "answer": "Суть в уже знакомом делении проекта на модули / фичи. Создаем папку modules, если есть пользователи, посты, какой нибудь конструктор сценариев, то появляются модули users, posts, scenarios-constructor.У каждого слоя модуля есть ограничения, он не может иметь доступ и использовать код с уровня ниже"
      }
    ]
  },
  {
    "tag": "hr",
    "name": "HR вопросы",
    "list": [
      {
        "question": "Расскажите о себе",
        "answer": "Разговорный вопрос",
        "time": 3
      },
      {
        "question": "Расскажите о предыдущем месте работы",
        "answer": "Разговорный вопрос",
        "time": 3
      },
      {
        "question": "Что для вас ценно в компаний",
        "answer": "Разговорный вопрос",
        "time": 3
      },
      {
        "question": "Расскажите об интересном проекте",
        "answer": "Разговорный вопрос",
        "time": 3
      },
      {
        "question": "Расскажите О решённых вами сложностях в проектах",
        "answer": "Разговорный вопрос",
        "time": 3
      }
    ]
  },
  {
    "tag": "base",
    "name": "Базовые вопросы",
    "list": [
      {
        "question": "doctype html - что это, и назовите отличия в версиях",
        "answer": "необходима, чтобы браузер понимал как обрабатывать текущую веб-страничку, так как существует несколько версий языка HTML"
      },
      {
        "question": "DOM - что это такое",
        "answer": "Document Object Model объектное представление html документа в javascript где каждый внутренний тег является дочерним массивом и вся эта структура выглядит в виде дерева"
      },
      {
        "question": "HTTP - что это такое",
        "answer": "это это протокол, позволяющий получать различные ресурсы в интернете, является протоколом клиент-серверного взаимодействия"
      },
      {
        "question": "HTTP - из чего остоит",
        "answer": "HEAD BODY",
        "time": 0.5
      },
      {
        "question": "МЕТОДЫ HTTP - назовите",
        "answer": "GET POST PUT DELETE",
        "time": 0.5
      },
      {
        "question": "DNC - что это такое",
        "answer": "это система доменных имён, которая сообщает браузеру по какому ip адресу идти, если браузер не знает, dnc - server"
      },
      {
        "question": "AJAX - что это такое",
        "answer": "Это набор методов веб-разработки, Недостатки Динамический контент не доступен для поисковиков"
      },
      {
        "question": "GET - что это такое",
        "answer": "Метод осуществляет запрос к серверу, у которого  все данные передаются в строке запроса."
      },
      {
        "question": "POST - что это такое",
        "answer": "данные  передаются не в строке запроса, а в его теле"
      },
      {
        "question": "КОДЫ ОТВЕТА СЕРВЕРА - назовите основные",
        "answer": "2 ок, 3 редирект, 4 ошибка клиента, 5 ошибка сервера"
      },
      {
        "question": "протокол TCP - что это такое",
        "answer": "TCP — это сокращение от Transmission Control Protocol (протокол управления передачей). TCP обозначает набор стандартизированных правил для обмена данными между различными устройствами в сети."
      },
      {
        "question": "JSONP - что это такое",
        "answer": "это дополнение к базовому формату JSON. Он предоставляет способ запросить данные с сервера, находящегося в другом домене."
      },
      {
        "question": "websocket - что это такое, и где вы применяли его",
        "answer": "независимый веб-протокол, который позволяет создавать интерактивное соединение между сервером и клиентом (браузером) и обмениваться сообщениями в реальном времени. В отличие от HTTP, веб-сокеты позволяют работать с двунаправленным потоком данных"
      },
      {
        "question": "MIME ТИП В ЗАПРОСАХ - что это такое, и пример отличия картинки от текста",
        "answer": "по нему можно определить что за тип содержимого нам пришло с сервера"
      },
      {
        "question": "Http only - что это такое",
        "answer": "это серверные куки,к которым нет доступа на клиенте"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - что это такое, назовите какие знаете",
        "answer": "Структура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом. массив, динамический массив, связный список, стек, очередь, Set, Map, Двоичное дерево поиска, Префиксное дерево,Граф"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - МАССИВ - что это такое",
        "answer": "Это наиболее простой пример структуры данных. Массив — это линейная последовательность значений, у каждого из которых есть свой номер. Номера называются индексами — по ним можно получить доступ к любому элементу массива."
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - ДИНАМИЧЕСКИЙ МАССИВ",
        "answer": "динамический массив — это тот, у которого размер может изменяться"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - СВЯЗНЫЙ СПИСОК",
        "answer": "Еще один распространенный пример линейной структуры данных. Это последовательность элементов, каждый из которых хранит данные и ссылку на следующий или предыдущий элемент. В результате от одного элемента можно быстро получить доступ к его «соседу».\n\nСами элементы, в отличие от массива, хранятся отдельно друг от друга. У них нет номеров. Последовательность достигается исключительно за счет указателей «следующий» и «предыдущий». Последний элемент будет указывать на «пустое» значение."
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - СТЕК",
        "answer": "Стек — структура, обратная очереди. Это последовательность, в которой доступ работает по принципу LIFO: Last In, First Out. Элементы добавляются в конец, а быстро получить и извлечь их можно опять же с конца. То есть чем позже элемент добавили в стек, тем легче до него добраться."
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - ОЧЕРЕДЬ",
        "answer": "Очередь похожа на массив. Это тоже линейная структура, состоящая из последовательности элементов. Разница в том, что доступ к этим элементам возможен только по принципу FIFO: First In, First Out. Это значит, что из очереди можно быстро и легко извлечь элемент, который расположен в самом ее начале и находится в ней дольше всего. А вот операций для доступа с конца или из середины может вообще не быть"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - SET",
        "answer": "В отличие от предыдущих базовых структур, во множестве данные не упорядочены. Они хранятся группой, их нельзя структурировать и в некоторых случаях нельзя сортировать.\n"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - MAP",
        "answer": "Её ещё называют ассоциативным массивом или словарём. Данные здесь хранятся в паре «ключ/значение», причем каждый ключ уникален, а вот значения могут повторяться.\n"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - ДВОИЧНОЕ ДЕРЕВО ПОИСКА",
        "answer": "Дерево — это структура, данные в которой лежат в узлах. У каждого узла могут быть один или несколько дочерних и только один родитель, то есть они расходятся, как ветви дерева:\n"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - ПРЕФИКСНОЕ ДЕРЕВО",
        "answer": "Другие названия этой структуры данных — Бор и нагруженное дерево. Данные в нём хранятся последовательно: каждый узел — это префикс, по которому находятся следующие узлы.\n"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ - ГРАФ",
        "answer": "Граф — нелинейная структура организации данных, которая состоит из «вершин» и «ребер» между ними. Каждая вершина — это значение, а ребра — пути, которые соединяют между собой вершины. Получается своеобразная «сетка», похожая на карту дорог или созвездие."
      }
    ]
  },
  {
    "tag": "cycles",
    "name": "Коллекций, Объекты, Циклы",
    "list": [
      {
        "question": "что такое OBJECT для javascript",
        "answer": "javascript представляет его ассоциативным массивом хранящим ключь=>значение, и имеющий несколько стандартных методов create,values\n"
      },
      {
        "question": "НАТИВНЫЕ ОБЪЕКТЫ это? перечислите их",
        "answer": "объекты, которые являются частью языка JavaScript String , Math , RegExp , Object , Function\n"
      },
      {
        "question": "ХОСТ-ОБЪЕКТЫ это?",
        "answer": "предоставляются средой выполнения (браузером или Node), такие как ` window `, ` XMLHTTPRequest `"
      },
      {
        "question": "МАССИВ что это? назовите его методы",
        "answer": "это тот же объект но с дополнительными методами к примеру length push slice splice"
      },
      {
        "question": "РАЗНИЦА МЕЖДУ АТРИБУТОМ И СВОЙСТВОМ",
        "answer": "свойства - это свойства самого объекта, а атрибуты - это элементы свойства attributes этого объекта"
      },
      {
        "question": "OBJECT.FREEZE() что это?",
        "answer": "замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости.\n"
      },
      {
        "question": "ПРОТОТИПЫ это?",
        "answer": "это механизм, с помощью которого объекты наследуют свойства друг от друга"
      },
      {
        "question": "что такое прототипное наследование?",
        "answer": "Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. "
      },
      {
        "question": "как проверить наличие свойства у объекта",
        "answer": "obj.hasownProperty(\"a\")",
        "time": 0.5
      },
      {
        "question": "что такое конструктор",
        "answer": "это либо функция либо оператор New позволящие нам создавать объекты"
      },
      {
        "question": "перечислите коллекций в javascript-е ",
        "answer": "SET, WeakSet MAP, WeakMap, МАССИВ",
        "time": 0.5
      },
      {
        "question": "что такое SET",
        "answer": "коллекция уникальных значений, так называемое «множество». без ключей где каждое значение может появляться только один раз. по сути массив let set = new Set([\"апельсин\", \"яблоко\", \"банан\"]);\n"
      },
      {
        "question": "что такое MAP",
        "answer": "коллекция пар ключ-значение. ключ может быть любым хоть числом хоть строкой"
      },
      {
        "question": "что такое WEAKSET И WEAKMAP",
        "answer": "их ключами могут быть только объекты"
      },
      {
        "question": "перечислите циклы в javascript-е и кратко расскажите их отличия",
        "answer": "for,forEach,map,filter,reduce, while",
        "time": 3
      },
      {
        "question": "опишите цикл FOREACH",
        "answer": "выполняет функцию callback один раз для каждого элемента"
      },
      {
        "question": "опишите цикл MAP",
        "answer": "выполняет функцию callback и возврощаемое значение добавляется в новый массив"
      },
      {
        "question": "опишите цикл FILTER",
        "answer": "создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.\n"
      },
      {
        "question": "опишите цикл REDUCE",
        "answer": "применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.\n"
      },
      {
        "question": "опишите цикл WHILE",
        "answer": "выполняется пока условие истина"
      }
    ]
  },
  {
    "tag": "html",
    "name": "Вёрстка",
    "list": [
      {
        "question": "Что такое CSS BOX MODEL",
        "answer": "это модель, которая описывает, из чего состоит бокс и какие свойства влияют на его размеры. В ней у каждого бокса есть 4 области: margin (внешние отступы), border (рамка), padding (внутренние поля), и content "
      },
      {
        "question": "В чём разница между TRANSITION ANIMATION",
        "answer": "TRANSITION позволяет сделать плавную анимацию двигаясь от точки А к точке Б, ANIMATION позволяют анимировать переходы от одной конфигурации CSS стилей к другой"
      },
      {
        "question": "Какие @media запросы вы знаете?",
        "answer": "PRINT для принтеров, (color) применятся ко всем цветным экранам, Retina для маковских устройств"
      },
      {
        "question": "Назовите селекторы",
        "answer": "~, *,id,class теги",
        "time": 0.5
      },
      {
        "question": "Какие псевдо элементы вы знаете?",
        "answer": ":before  :after :placeholder",
        "time": 0.5
      },
      {
        "question": "Какие псевдо классы вы знаете?",
        "answer": ":link :visited :checked ,:hover :active :first-of-type :disabled, :nth-child(2n+12) если выделить какой то после нескольких"
      },
      {
        "question": "Что такое миксины",
        "answer": "это заданный нами отдельной кусок css кода который мы переиспользуем много раз либо в оригинальном варианте либо передавая ему через переменные новые значения"
      },
      {
        "question": "html entities это?",
        "answer": "HTML сущности это это части текста ('строки'), которые начинаются с символа амперсанда ( & ) и заканчиваются точкой с запятой ( ; ) пример не разрывный пробел, символ рубля в коде и подобные"
      }
    ]
  },
  {
    "tag": "javascript",
    "name": "Javascript",
    "list": [
      {
        "question": "Какие типы данных вы знаете? ",
        "answer": "number,string,null,undefined,boolean,объект,символ,bigint. Строки, числа, булевые это примитивные типы остальные сложные"
      },
      {
        "question": "в чём отличие null ОТ undefined",
        "answer": "null пустое значение undefined не определено",
        "time": 0.5
      },
      {
        "question": "NAN это?",
        "answer": "not n number значение не число, когда привидение к числу не срабатывает",
        "time": 0.5
      },
      {
        "question": "VAR LET CONST чем отличаются?",
        "answer": "var можно пересоздавать и менять ЗНАЧЕНИЕ, имеет область видимости ограниченную функцией , \nlet создаёт область видимости внутри блока {} пересозданная let внутри {} значение остаётся внутри, переназначенная внутри {} передаёт значение наружу,обл видимости let = const"
      },
      {
        "question": "что такое мёртвая зона",
        "answer": "let const не подверженны всплытию по этому между местом их объявления и верхней границей области видимости мёртвая зона"
      },
      {
        "question": "что такое HOSTING",
        "answer": "это когда обявленные переменные поднимаются на верх всплывая до верха своего уровня видимости"
      },
      {
        "question": "javascript это?",
        "answer": "интерпретируемый, слабо типизирован, Язык для динамического управления контентом"
      },
      {
        "question": "что такое компилируемый язык",
        "answer": "который перед использованием надо скомпилировать в машинный язык работает гораздо быстрее C C++"
      },
      {
        "question": "что такое интерпретируемый язык",
        "answer": "интерпретируемым для исполнения программы не нужен машинный код там интерпретаторы выполняют код PHP"
      },
      {
        "question": "расскажите про EVENT LOOP",
        "answer": "Цикл событий в JAVASCRIPT"
      },
      {
        "question": "МИКРО МАКРО ТАСКИ чем отличаются ",
        "answer": "сеттаймауты это макро таски, промисы микро таски, в EVENT LOOP сперва выполняются микро таски затем макро, за раз выполняется только 1 макро таск"
      },
      {
        "question": "что такое аттрибут ASING",
        "answer": "при обнаружении <script async src=\"...\"> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится."
      },
      {
        "question": "что такое аттрибут DEFER",
        "answer": "Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.\t\t\n\t\t\tПервое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.\n\t\t\tВторое отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.\n"
      },
      {
        "question": "что такое ДЕСКРИПТОРЫ",
        "answer": "позволяют ограничивать доступ, чтение определённых свойст пример setter-на чтение, getter-на запись, rait-на запись, enumerebol-будет ли это свойство перечислятся среди свойст объекта\n"
      },
      {
        "question": "что такое GETTER SETTER",
        "answer": "свойства GETTER срабатывает, когда объект читается, сеттер – когда значение присваивается"
      },
      {
        "question": "как проверить тип данных",
        "answer": "typeof(x) возвращает тип данных аргумента"
      },
      {
        "question": "что нужно сделать что бы проверить что это объект",
        "answer": "Array.isArray()",
        "time": 0.5
      },
      {
        "question": "проверить на NAN",
        "answer": "Array.isNaN()",
        "time": 0.5
      },
      {
        "question": "какие операторы вы знаете?",
        "answer": "Сравнение,Присваивание,Арифметические,Тернарный,Логический"
      },
      {
        "question": "что такое логические операторы",
        "answer": "|| (ИЛИ), && (И) и ! (НЕ), ?? (Оператор нулевого слияния) a || b если один из a,b = true вернёт true \n"
      },
      {
        "question": "тернарный оператор это? и в чём отличие от if",
        "answer": "оператор в JavaScript, принимающий три операнда: условие, за которым следует знак вопроса (?), затем выражение, которое выполняется, если условие истинно, сопровождается двоеточием (:)  \nи наконец выражение, которое выполняется, если условие ложно.\n"
      },
      {
        "question": "двойное == и тройное === сравнение в чём отличие",
        "answer": "первый сравнивает значения после их преобразования к одному типу, а второй — без приведения \n(undefined==null=true) ('0'==false=true) (false=='',[]=true)  (false=={}=false) (''==0,[]=true) (''=={}=false) (0==[]=true) (0=={},null=false)\n"
      },
      {
        "question": "Назовите ложные значения",
        "answer": "false,Number : 0 И -0, \"\" '',undefined,null,nan,bigint(0) ЕСЛИ ДЛИНА СТРОКИ 0"
      },
      {
        "question": "что такое API ",
        "answer": "это программный интерфейс для общения компонентов программы друг с другом\n"
      },
      {
        "question": "Какие протоколы в API вы знаете",
        "answer": "REST RPC",
        "time": 0.5
      },
      {
        "question": "что такое архитектура REST",
        "answer": "архитектурный стиль взаимодействия компонентов распределённого приложения  приложения в сети с использованием http протокола, в качестве ответа выдаётся веб\n сервер выдаёт формат данных json или ixm"
      },
      {
        "question": "что такое ДЕКОМПОЗИЦИЯ, ДЕСТРУКТУРИЗАЦИЯ",
        "answer": "это синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.  let {name, email} = user; user исходный объект"
      },
      {
        "question": "что такое SPREED-ОПЕРАТОР и для чего нужен",
        "answer": "это три точки перед именем переменной (или константы) Он раскладывает соответствующий объект внутри нового объекта. С его помощью можно получить только копию, он не может изменять существующие объекты."
      },
      {
        "question": "опишите РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ",
        "answer": "это шаблоны, используемые для сопоставления последовательностей символов в строках. применяется к примеру в match, replace, search\n"
      }
    ]
  },
  {
    "tag": "typescript",
    "name": "Typescript",
    "list": [
      {
        "question": "typescript это",
        "answer": "TypeScript представляет язык программирования на основе JavaScript, компилируемый язык, так же он реализует концепций ооп и наследование, полиморфизм, инкапсуляция и модификаторы доступа и так далее, упрощает написание сложного кода\n"
      },
      {
        "question": "что такое декораторы? И что они делают",
        "answer": "инструмент позволяющий добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода (функция, которую надо добавить перед классом свойством или методом со знаком @) применяются к классам\n"
      },
      {
        "question": "что такое модификаторы доступа",
        "answer": "public\n\t\t\tprotected определяет поля и методы, которые из вне класса видны только в классах-наследниках:\n\t\t\tprivate, то к ним нельзя будет обратиться извне при создании объекта данного класса.\n"
      },
      {
        "question": "утиная типизация это?",
        "answer": "определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов\n"
      },
      {
        "question": "Оператор type что это?",
        "answer": "Оператор type позволяет определить новый псевдоним для существующего типа, type Login = string;const login:login = 'admin"
      },
      {
        "question": "INTERFACE (Интерфейсы) что это?",
        "answer": "это синтаксическая конструкция, предназначенная для описания открытой ( public ) части объекта без реализации (api) interface rect {readonly id: string color?: string} readonly ? означает не обязательный const rect1: Rect = {id: '1234',color: 'black'}\n"
      },
      {
        "question": "ИНТЕРФЕЙС/ТИП - ОТЛИЧИЕ",
        "answer": "Типы являются более предпочтительным вариантом, так как вы можете заменить интерфейсы типами, но не наоборот. Для использования продвинутой функциональности TypeScript - mapped типов, объединения типов и условных типов \nинтерфейсы не подойдут."
      },
      {
        "question": "что такое ENUM",
        "answer": "вспомогательная сущность для структурирования однотипного кода enum Mem {sim,sta,pre} const mem = Mem.sta\n"
      },
      {
        "question": "что такое READONLY",
        "answer": "означает только для чтения"
      },
      {
        "question": "GENERICS ТИПЫ это?",
        "answer": "параметр-тип T, используется указывая функций что она будет работать с разными типами данных fun revers <T>(arrray:T[]): T[]\n"
      }
    ]
  },
  {
    "tag": "function",
    "name": "Функций и события",
    "list": [
      {
        "question": "что такое FUNCTION",
        "answer": "это объект, которым можно манипулировать, передать параметры,  функция может что то возвращать,используются как бы для инкапсуляций логики,нупо сути и является строительным инструментом для обособления некого функционала \n"
      },
      {
        "question": "что такое FUNCTION EXPRESSION",
        "answer": "объявление функции в контексте какого-либо выражения, например присваивания, к примеру в map, данная функция должна что то вернуть помещается в переменную\n"
      },
      {
        "question": "что такое FUNCTION DECLARATION\n",
        "answer": "можем использовать в любой момент(имеет имя) которое служит в качестве переменной\n"
      },
      {
        "question": "КОНТЕКСТ это?",
        "answer": "если функция стрелочная то берётся из окружения так как не имеет своего если обычная то берёт от туда от куда была вызвана, контекст может быть своим либо переданным через call aplay, bind то же может изменить контекст но только 1 раз\n"
      },
      {
        "question": "КОНТЕКСТ И ОБЛАСТЬ ВИДИМОСТИ ОТЛИЧИЯ",
        "answer": "область видимости относится к переменным а контекст относится к функций к тому что оперирует данными,и они применяются по разному\n"
      },
      {
        "question": "ЧИСТАЯ ФУНКЦИЯ это?",
        "answer": "это функция которая выдаёт нам ожидаемый результат"
      },
      {
        "question": "АНОНИМНАЯ ФУНКЦИЯ это?",
        "answer": "часто используются для выполнения какого-то кода в коллбэках, где в целом не нужно создавать отдельную именную функцию под это действие"
      },
      {
        "question": "EVAL это?",
        "answer": "опасная функция, которая позволяет создать код на лету и выполнить его, это делает код не безопастным, так как мы можем подменить код и он выполнится, по сути это  код на который могут влиять злоумышленники,\n и который выполнится на правах нашей строницы"
      },
      {
        "question": "ЗАМЫКАНИЕ JS это?",
        "answer": "функция внутри функций, это способность функций,  запоминать ссылки на переменные и параметры, на своём уровне видимости, примменение когда надо переменную сделать приватной и не доступной из вне кроме как через функцию\n"
      },
      {
        "question": "EVENT это?",
        "answer": "объект который содержит свойства, описывающие некое событие."
      },
      {
        "question": "THIS это?",
        "answer": "это переменная в функции, ссылка на объект который вызывает эту функцию или текущий элемент, до которого дошло всплытие и на нём сейчас выполняется обработчик.\n"
      },
      {
        "question": "SCOPE это?",
        "answer": "это внутреннее скрытое свойство функции, которое она получает во время вызова,  обратится можно через THIZ\n"
      },
      {
        "question": "ЧТО БЫ ОСТАНОВИТЬ SETTIMEOUT",
        "answer": "clearTimeout"
      },
      {
        "question": "МЕТОД CALL",
        "answer": "позволяет вызвать функцию с заданным контекстом. Первым параметром метода следует указывать контекст функции, а остальными параметрами - параметры функции. fun.call(thisArg[, arg1[, arg2[, ...]]])\n"
      },
      {
        "question": "МЕТОД APPLAY",
        "answer": "то же самое но только ВТОРОЙ ПАРАМЕТР ОБЯЗАТЕЛЬНО МАССИВ fun.apply(thisArg, [argsArray])\n"
      },
      {
        "question": "МЕТОД BIND ОБЪЕКТ",
        "answer": "не вызывает а возвращает новую функцию  fun.bind(thisArg[, arg1[, arg2[, ...]]])\n"
      },
      {
        "question": "ОБРАБОТЧИКИ СОБЫТИИ JS",
        "answer": "click,submit,keydown,keyup и подобные"
      },
      {
        "question": "ВСПЛЫТИЕ, ПОГРУЖЕНИЕ",
        "answer": "ВСПЛЫТИЕ Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.\n\t\t\tПОГРУЖЕНИЕ событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.\n\t\t\tДля остановки всплытия нужно вызвать метод event. stopPropagation()\n"
      },
      {
        "question": "ASSING",
        "answer": "функция для копирования объектов, и избавления от ссылочной зависимости, но если внутри объекта будет ещё объект то ссылка на него сохраняется\n"
      },
      {
        "question": "ДЕЛЕГИРОВАНИЕ",
        "answer": "Вместо прикрепления обработчиков событий прямо к кнопкам, мы делегируем отслеживание этого события родительскому элементу <div id=\"buttons\">. Когда нажимается кнопка, обработчик, назначенный родительскому элементу ловит\n всплывающее событие затем через event.target проверяем на какой кнопке произошёл клик\n"
      },
      {
        "question": "REFLOW",
        "answer": "Пересчёт (Reflow) происходит, когда браузер должен снова обработать и отрисовать часть или всю веб-страницу, например, после изменения размера какого-нибудь блока или изменения его позиции на интерактивном сайте.\n"
      },
      {
        "question": "FEATURE DETECTION",
        "answer": "определение возможностей браузера"
      },
      {
        "question": "INTERFERENCE",
        "answer": "inference определяет  возможные способности браузера"
      },
      {
        "question": "USER AGENT",
        "answer": "User Agent определяет тип браузера"
      },
      {
        "question": "Проверить на целое число",
        "answer": "делим на 1 и проверяем остаток console.log(5 % 1) = thue"
      },
      {
        "question": "IIEF",
        "answer": "Функций моментального вызова"
      }
    ]
  },
  {
    "tag": "async",
    "name": "Асинхронность",
    "list": [
      {
        "question": "ПРОМИСЫ",
        "answer": "объект использующийся для отложенных и асинхронных вычислений. Используется когда надо что бы одна часть кода выполнялась после другой к примеру при работе с сервером, имеет состояния Ожидающий выполенный отклонённый"
      },
      {
        "question": "ПРОМИСЫ СТАТИ-КИЕ МЕТОДЫ",
        "answer": ".all .allSettled Полифил .race .reject  .resolve "
      },
      {
        "question": "МЕТОД PROMISE.ALL",
        "answer": "возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента, или отклонено любое из переданных промисов.\n"
      },
      {
        "question": "МЕТОД PROMISE.ALLSETTLED()",
        "answer": "возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.\n"
      },
      {
        "question": "PROMISE.RESOLVE(VALUE)",
        "answer": "возвращает Promise выполненный с переданным значением"
      },
      {
        "question": "PROMISE.REJECT",
        "answer": "возвращает Promise который был отклонён"
      },
      {
        "question": "PROMISE.RACE(ITERABLE)",
        "answer": "возвращает выполненный или отклонённый промис, в зависимости от того, с каким результатом завершится первый из переданных промисов, со значением или причиной\n отклонения этого промиса."
      },
      {
        "question": "PROMISE.THEN",
        "answer": "Универсальный метод для навешивания обработчиков"
      },
      {
        "question": "PROMISE.CATCH",
        "answer": "бработчик только на ошибку, вместо .then"
      },
      {
        "question": "ASYNG/AWAIT",
        "answer": "специальный синатксис, функция помеченная asyng возвращаемый результат оборачивает как промис и внутри мы можем использовать await\n"
      },
      {
        "question": "РАЗНИЦА МЕЖДУ ПРОМИС И ASYNG/AVAYT",
        "answer": "более лакончное написание, отсуствие вложнности"
      },
      {
        "question": "ПРОМИСЫ СТАТУСЫ",
        "answer": "pending ожидание,fulfilled исполнено, rejected отклонено, 4 статус действия окончены"
      }
    ]
  },
  {
    "tag": "es6",
    "name": "Ecmascript 6",
    "list": [
      {
        "question": "TEMPLATE LITERALS, ШАБЛОННЫЕ ЛИТЕРАЛЫ",
        "answer": "это кривые ковычки `` позволяющие вставлять js в код html  ` ${ X-test }  `"
      },
      {
        "question": "НАСЛЕДОВАНИЕ EXTENDS",
        "answer": "означает - он получает все из своего родителя"
      },
      {
        "question": "ES 6 CLASS это",
        "answer": "это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы)\n"
      },
      {
        "question": "ИНТЕРФЕЙС interface - это",
        "answer": "определяет свойства и методы, которые объект должен реализовать. то есть это определение кастомного типа данных, но без реализации."
      },
      {
        "question": "IMPLEMENTS",
        "answer": "в этом случае почти как реализация интерфейса. Детский объект может притворяться, что он является родителем. но он не получает никакой реализации.\n"
      },
      {
        "question": "АБСТРАКТНЫЙ КЛАСС",
        "answer": "они не компилируются а используются в основном для наследования от них в процессе разработки, в них присутствуют обстрактные методы\n"
      },
      {
        "question": "IMPORT/EXPORT MODULE",
        "answer": "используются на этапе разработки и в конце всё сливается в единый файл байдинг,применённый импорт не дублируется и если мы импортировали несколько раз одно и то же то применится оно 1 раз\n"
      },
      {
        "question": "IMPORT ОСОБЕННОСТЬ",
        "answer": "если импортим (объект) то можем поменять его во всех модулях применив изменение только в одном месте так как объекты ссылочные а если примитив (переменная) то нет\n"
      },
      {
        "question": "СТАТИЧЕСКИЙ КЛАСС ",
        "answer": "класс, состоящий исключительно из статических методов и свойств.\n"
      }
    ]
  },
  {
    "tag": "oop",
    "name": "ООП",
    "list": [
      {
        "question": "ПРИНЦИПЫ ООП",
        "answer": "Наследование Инкапсуляция Полиморфизм"
      },
      {
        "question": "ООП НАСЛЕДОВАНИЕ ",
        "answer": "концепция, согласно которой абстрактный тип данных может наследовать данные и функциональность реализуется через extends "
      },
      {
        "question": "АБСТРАКЦИЯ",
        "answer": "означает выделение главных, наиболее значимых характеристик и скрытие не особо значимых \n"
      },
      {
        "question": "ИНКАПСУЛЯЦИЯ ",
        "answer": "размещение в одном компоненте данных и методов, которые с ними работают, так что доступ к этим данным ограничен извне\n"
      },
      {
        "question": "ПОЛИМОРФИЗМ ",
        "answer": "способность функции обрабатывать данные разных типов"
      },
      {
        "question": "SOLID ",
        "answer": "это аббревиатура пяти основных принципов проектирования в объектно‑ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion.\n"
      },
      {
        "question": "1) SINGLE RESPONSIBILITY\n",
        "answer": "принцип единственной ответственности\n"
      },
      {
        "question": "2) OPEN-CLOSED\n",
        "answer": "принцип открытости / закрытости\n"
      },
      {
        "question": "3) LISKOV SUBSTITUTION\n",
        "answer": "принцип подстановки Барбары Лисков\n"
      },
      {
        "question": "4) INTERFACE SEGREGATION\n",
        "answer": "принцип разделения интерфейса\n"
      },
      {
        "question": "5) DEPENDENCY INVERSION\n",
        "answer": "принцип инверсии зависимостей суть которого состоит в том, что классы должны зависеть от абстракций, а не от конкретных деталей\n"
      },
      {
        "question": "DEPENDENCY INJECTION\n",
        "answer": "Концепция Dependency Injection состоит в том, чтобы перенести ответственность за создание экземпляра объекта из тела метода за пределы класса и передать уже созданный экземпляр объекта обратно.\n"
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "tag": "vue3",
    "name": "Vue 3",
    "list": [
      {
        "question": "какие LIFECYCLE HOOKS VUE3 вы знаете",
        "answer": "onMounted onUpdated onUnmounted onActivated onDeactivated\n"
      },
      {
        "question": "опишите ЖИЗНЕННЫЙ ЦИКЛ компонента",
        "answer": "INIT(events&lifecycle) BeforeCreate -> INIT(injections&reactivite) Created -> beforeMount CREATED APP mounted -> MOUNTED beforeUnmount -> UNMOUNT -> unmounted\n"
      },
      {
        "question": "как утстроена РЕАКТИВНОСТЬ VUE",
        "answer": "переменные объявленные в коде просто отображаются в шаблоне. При этом при изменение значения переменных в коде они автоматически будут обновляется в шаблоне. Такой механизм и называется реактивность Vue.js\n"
      },
      {
        "question": "что такое ВЫЧИСЛЯЕМЫЕ СВОЙСТВА",
        "answer": "они представляют из себя функций определяемые в поле COMPUTED которые возвращают результат каких то вычислений x-test: function () { return a+b} но отличие от обычных функций в том что они кешируются и изменяются когда меняется переменная\n в свойстве\n"
      },
      {
        "question": "что такое ОТСЛЕЖИВАЕМЫЕ СВОЙСТВА\n",
        "answer": "объявляются в WATCH и явсляются функциями которые именуются так же как переменная за которой надо следить\n"
      },
      {
        "question": "назовите ДИРЕКТИВЫ",
        "answer": "v-if,v-else,v-else-if,v-show,v-for,v-model,v-on,v-bind,v-text,v-slot,v-pre\n"
      },
      {
        "question": "V-IF /  V-SHOW РАЗНИЦА\n",
        "answer": "в том что SHOW скрывает но не удаляет а IF удаляет из DOM\n"
      },
      {
        "question": "что это и для чего нужно V-KEY: X-TEST\n",
        "answer": "Добавление уникального ключа компоненту что бы при перерисовке дома он не вызывал свой методы и свойства если в нём дом не менялся\n"
      },
      {
        "question": "что такое Методы\n",
        "answer": "на примере функций они будут производить вычисления при любом обращений\n"
      },
      {
        "question": "передача данных РОДИТЕЛЬ ---> СЫН\n",
        "answer": "props,store provide позволяет игнорировать вложенность, vueX pinia плагин позволяющий так же передавать и подписыватся на изменения \n"
      },
      {
        "question": "передача данных СЫН ---> РОДИТЕЛЬ\n",
        "answer": "$emit, vueX pinia"
      },
      {
        "question": "$EMIT ЭТО\n",
        "answer": "событие позволяющее передать данные из дочернего компонента в родительский с помощью подписки в родительском\n"
      },
      {
        "question": "Функция computed() это?",
        "answer": "вычисляемые свойства, ещё они кешируются будут производить вычисления только при изменений данных которые влият на результат\n"
      },
      {
        "question": "Функция WATCH() это?",
        "answer": "для отслеживания переменной, и при изменении этой переменной он позволяет нам запускать функцию, чтобы мы могли выполнять динамическое взаимодействие.\n"
      },
      {
        "question": "что такое ИНТЕРПОЛЯЦИЯ\n",
        "answer": "привязка к шаблону для вывода данных в него через {{x-test}}\n"
      },
      {
        "question": "что такое МИКСИНЫ\n",
        "answer": "переиспользуемый js код который может содержать теже методы что и компонет, подключаем через mixins:[x-test] в export default\n"
      },
      {
        "question": "как устанавливается СЛУШАТЕЛЬ СОБЫТИЯ и какие они бывают",
        "answer": "v-on:click=\"x-test\" или сокращённый вариант @click=\"x-test\"\n"
      },
      {
        "question": "какие МОДИФИКАТОРЫ СОБЫТИЙ существуют",
        "answer": "@click.stop = stopPropagation, @click.prevent = preventdefault, .right , .alt , .capture итд \n"
      },
      {
        "question": "МОДИФИКАТОРЫ У V-MODEL\n",
        "answer": "v-model.number преобразовывает значение к числу, lazy меняет поведение на on-change, trim удаляет пробелы\n"
      },
      {
        "question": "ГЛОБАЛЬНАЯ РЕГИСТРАЦИЯ\n",
        "answer": "компоненты регестрируются через app.component('x-test',Component) в main.js\n"
      },
      {
        "question": "как сменить класс CSS в доме",
        "answer": "data(return{toggle:false}) <button @click=\"toggle = !toggle\"> <div :class=\"{x-test:toggle}\">\n"
      },
      {
        "question": "что такое REF\n",
        "answer": "даёт доступ к DOM элементам <input ref=\"x-test\"> methods:{getRef(){console.log(this.$refs.x-test)}}\n"
      },
      {
        "question": "в чём разница между Ref и reactive",
        "answer": "Ref используется для создания реактивных ссылок на значения. Reactive преобразует объекты в реактивный объект. Он делает все свойства объекта реактивными. Или иначе ref возвращает простой объект а reactive сложный "
      }
    ]
  }
]