[
  {
    "tag": "Базовые вопросы",
    "list": [
      {
        "question": "DOCETYPE",
        "answer": "необходима, чтобы браузер понимал как обрабатывать текущую веб-страничку, так как существует несколько версий языка HTML\n"
      },
      {
        "question": "DOM",
        "answer": "Document Object Model объектное представление html документа в javascript где каждый внутренний тег является дочерним массивом и вся эта структура выглядит в виде дерева\n"
      },
      {
        "question": "HTTP",
        "answer": "это это протокол, позволяющий получать различные ресурсы в интернете, является протоколом клиент-серверного взаимодействия\n"
      },
      {
        "question": "HTTP ИЗ ЧЕГО СОСТОИТ",
        "answer": "HEAD BODY "
      },
      {
        "question": "МЕТОДЫ HTTP",
        "answer": "GET POST PUT DELETE"
      },
      {
        "question": "DNC",
        "answer": "это система доменных имён, которая сообщает браузеру по какому ip адресу идти, если браузер не знает, dnc - server"
      },
      {
        "question": "AJAX",
        "answer": "Это набор методов веб-разработки, Недостатки Динамический контент не доступен для поисковиков"
      },
      {
        "question": "GET ",
        "answer": "Метод осуществляет запрос к серверу, у которого  все данные передаются в строке запроса."
      },
      {
        "question": "POST ",
        "answer": "данные  передаются не в строке запроса, а в его теле"
      },
      {
        "question": "КОДЫ ОТВЕТА СЕРВЕРА",
        "answer": "2 ок, 3 редирект, 4 ошибка клиента, 5 ошибка сервера"
      },
      {
        "question": "протокол TCP",
        "answer": "протокол управления передачей надстройка над http более высокая"
      },
      {
        "question": "JSONP",
        "answer": "это дополнение к базовому формату JSON. Он предоставляет способ запросить данные с сервера, находящегося в другом домене."
      },
      {
        "question": "websocket",
        "answer": "протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени\n"
      },
      {
        "question": "MIME ТИП В ЗАПРОСАХ",
        "answer": "по нему можно определить что за тип содержимого нам пришло с сервера"
      },
      {
        "question": "Http only",
        "answer": "это серверные куки,к которым нет доступа на клиенте"
      },
      {
        "question": "СТРУКТУРЫ ДАННЫХ",
        "answer": "массив, динамический массив, связный список, стек, очередь, Set, Map, Двоичное дерево поиска, Префиксное дерево,Граф"
      },
      {
        "question": "структура данных МАССИВ",
        "answer": "одномерный,многомерный - Одна из самых простых структур данных, которая встречается чаще всего. Именно на массивах основаны многие другие структуры данных: списки, стеки, очереди.\n"
      },
      {
        "question": "структура данных ДИНАМИЧЕСКИЙ МАССИВ",
        "answer": "динамический массив — это тот, у которого размер может изменяться"
      },
      {
        "question": "структура данных СВЯЗНЫЙ СПИСОК",
        "answer": "Связный список — это группа из узлов. В каждом узле содержатся: Данные Указатель или ссылка на следующий узел. В некоторых списках — ещё и ссылка на предыдущий узел.\n"
      },
      {
        "question": "структура данных СТЕК",
        "answer": "Эта структура данных позволяет добавлять и удалять элементы только из начала. Она работает по принципу «последним пришёл — первым ушёл». Последний добавленный в стек элемент должен будет покинуть его раньше остальных\n"
      },
      {
        "question": "структура данных ОЧЕРЕДЬ",
        "answer": "Этот вид структуры представляет собой ряд данных, как и стек. Но в отличие от него она работает по принципу FIFO — First In, First Out (англ. «первым пришёл — первым ушёл»). Данные добавляют в конец, а извлекают из начала.\n"
      },
      {
        "question": "структура данных SET",
        "answer": "В отличие от предыдущих базовых структур, во множестве данные не упорядочены. Они хранятся группой, их нельзя структурировать и в некоторых случаях нельзя сортировать.\n"
      },
      {
        "question": "структура данных MAP",
        "answer": "Её ещё называют ассоциативным массивом или словарём. Данные здесь хранятся в паре «ключ/значение», причем каждый ключ уникален, а вот значения могут повторяться.\n"
      },
      {
        "question": "структура данных ДВОИЧНОЕ ДЕРЕВО ПОИСКА\n",
        "answer": "Дерево — это структура, данные в которой лежат в узлах. У каждого узла могут быть один или несколько дочерних и только один родитель, то есть они расходятся, как ветви дерева:\n"
      },
      {
        "question": "структура данных ПРЕФИКСНОЕ ДЕРЕВО",
        "answer": "Другие названия этой структуры данных — Бор и нагруженное дерево. Данные в нём хранятся последовательно: каждый узел — это префикс, по которому находятся следующие узлы.\n"
      },
      {
        "question": "структура данных ГРАФ",
        "answer": "Граф — это более общий случай дерева. Иногда деревья называют ациклическими графами.\n"
      },
      {
        "question": "FSD",
        "answer": "то архитектурная методология для проектирования фронтенд-приложений. Проще говоря, это набор правил и соглашений по организации кода. Главная цель этой методологии — сделать проект понятнее и стабильнее в условиях постоянно меняющихся бизнес-требований.\n"
      }
    ]
  },
  {
    "tag": "Коллекций, Объекты, Циклы",
    "list": [
      {
        "question": "OBJECT ДЛЯ JAVASCRIPT",
        "answer": "javascript представляет его ассоциативным массивом хранящим ключь=>значение, и имеющий несколько стандартных методов create,values\n"
      },
      {
        "question": "НАТИВНЫЕ ОБЪЕКТЫ",
        "answer": "объекты, которые являются частью языка JavaScript String , Math , RegExp , Object , Function\n"
      },
      {
        "question": "ХОСТ-ОБЪЕКТЫ",
        "answer": "предоставляются средой выполнения (браузером или Node), такие как ` window `, ` XMLHTTPRequest `"
      },
      {
        "question": "МАССИВ",
        "answer": "это тот же объект но с дополнительными методами к примеру length push slice splice"
      },
      {
        "question": "РАЗНИЦА МЕЖДУ АТРИБУТОМ И СВОЙСТВОМ",
        "answer": "свойства - это свойства самого объекта, а атрибуты - это элементы свойства attributes этого объекта"
      },
      {
        "question": "OBJECT.FREEZE()",
        "answer": "замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости.\n"
      },
      {
        "question": "ПРОТОТИПЫ",
        "answer": "это механизм, с помощью которого объекты наследуют свойства друг от друга"
      },
      {
        "question": "ПРОТОТИП НАСЛЕДОВАНИЕ",
        "answer": "Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. "
      },
      {
        "question": "ПРОВЕРИТЬ НАЛИЧИЕ СВОЙСТВА У ОБЪЁКТА ",
        "answer": "obj.hasownProperty(\"a\")"
      },
      {
        "question": "КОНСТРУКТОР",
        "answer": "это либо функция либо оператор New позволящие нам создавать объекты"
      },
      {
        "question": "КОЛЛЕКЦИЙ JS",
        "answer": "тип SET, WeakSet  тип MAP, WeakMap, МАССИВ, "
      },
      {
        "question": "SET",
        "answer": "коллекция уникальных значений, так называемое «множество». без ключей где каждое значение может появляться только один раз. по сути массив let set = new Set([\"апельсин\", \"яблоко\", \"банан\"]);\n"
      },
      {
        "question": "MAP",
        "answer": "коллекция пар ключ-значение. ключ может быть любым хоть числом хоть строкой"
      },
      {
        "question": "WEAKSET И WEAKMAP",
        "answer": "их ключами могут быть только объекты"
      },
      {
        "question": "ЦИКЛЫ JS",
        "answer": "for,forEach,map,filter,reduce, while"
      },
      {
        "question": "Цикл FOREACH",
        "answer": "выполняет функцию callback один раз для каждого элемента"
      },
      {
        "question": "Цикл MAP",
        "answer": "выполняет функцию callback и возврощаемое значение добавляется в новый массив"
      },
      {
        "question": "Цикл FILTER",
        "answer": "создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.\n"
      },
      {
        "question": "Цикл REDUCE",
        "answer": "применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.\n"
      },
      {
        "question": "Цикл WHILE",
        "answer": "выполняется пока условие истина"
      }
    ]
  },
  {
    "tag": "вёрстка",
    "list": [
      {
        "question": "CSS BOX MODEL",
        "answer": "это модель, которая описывает, из чего состоит бокс и какие свойства влияют на его размеры. В ней у каждого бокса есть 4 области: margin (внешние отступы), border (рамка), padding (внутренние поля), и content "
      },
      {
        "question": "TRANSITION ANIMATION",
        "answer": "TRANSITION позволяет сделать плавную анимацию двигаясь от точки А к точке Б, ANIMATION позволяют анимировать переходы от одной конфигурации CSS стилей к другой"
      },
      {
        "question": "@media",
        "answer": "PRINT для принтеров, (color) применятся ко всем цветным экранам, Retina для маковских устройств"
      },
      {
        "question": "Селекторы",
        "answer": "~, *,id,class теги"
      },
      {
        "question": "псевдо элементы",
        "answer": ":before  :after :placeholder"
      },
      {
        "question": "псевдо классы",
        "answer": ":link :visited :checked ,:hover :active :first-of-type :disabled, :nth-child(2n+12) если выделить какой то после нескольких"
      },
      {
        "question": "миксины",
        "answer": "это заданный нами отдельной кусок css кода который мы переиспользуем много раз либо в оригинальном варианте либо передавая ему через переменные новые значения"
      },
      {
        "question": "html entities",
        "answer": "HTML сущности это это части текста ('строки'), которые начинаются с символа амперсанда ( & ) и заканчиваются точкой с запятой ( ; ) пример не разрывный пробел, символ рубля в коде и подобные"
      }
    ]
  },
  {
    "tag": "javascript",
    "list": [
      {
        "question": "ТИПЫ ДАННЫХ",
        "answer": "number,string,null,undefined,boolean,объект,символ,bigint. Строки, числа, булевые это примитивные типы остальные сложные"
      },
      {
        "question": "Отличие null ОТ undefined",
        "answer": "null пустое значение undefined не определено"
      },
      {
        "question": "NAN",
        "answer": "not n number значение не число, когда привидение к числу не срабатывает"
      },
      {
        "question": "VAR LET CONST",
        "answer": "var можно пересоздавать и менять ЗНАЧЕНИЕ, имеет область видимости ограниченную функцией , \nlet создаёт область видимости внутри блока {} пересозданная let внутри {} значение остаётся внутри, переназначенная внутри {} передаёт значение наружу,обл видимости let = const"
      },
      {
        "question": "МЁРТВАЯ ЗОНА",
        "answer": "let const не подверженны всплытию по этому между местом их объявления и верхней границей области видимости мёртвая зона"
      },
      {
        "question": "HOSTING",
        "answer": "это когда обявленные переменные поднимаются на верх всплывая до верха своего уровня видимости"
      },
      {
        "question": "JAVASCRIPT ЭТО",
        "answer": "интерпретируемый, слабо типизирован, Язык для динамического управления контентом"
      },
      {
        "question": "КОМПИЛИРУЕМЫЙ ЯЗЫК",
        "answer": "который перед использованием надо скомпилировать в машинный язык работает гораздо быстрее C C++"
      },
      {
        "question": "ИНТЕРПРИТИРУЕМЫЙ ЯЗЫК",
        "answer": "интерпретируемым для исполнения программы не нужен машинный код там интерпретаторы выполняют код PHP"
      },
      {
        "question": "EVENT LOOP",
        "answer": "Цикл событий в JAVASCRIPT"
      },
      {
        "question": "МИКРО МАКРО ТАСКИ",
        "answer": "сеттаймауты это макро таски, промисы микро таски, в EVENT LOOP сперва выполняются микро таски затем макро, за раз выполняется только 1 макро таск"
      },
      {
        "question": "ASING",
        "answer": "при обнаружении <script async src=\"...\"> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится."
      },
      {
        "question": "DEFER",
        "answer": "Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.\t\t\n\t\t\tПервое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.\n\t\t\tВторое отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.\n"
      },
      {
        "question": "ДЕСКРИПТОРЫ",
        "answer": "позволяют ограничивать доступ, чтение определённых свойст пример setter-на чтение, getter-на запись, rait-на запись, enumerebol-будет ли это свойство перечислятся среди свойст объекта\n"
      },
      {
        "question": "GETTER SETTER",
        "answer": "свойства GETTER срабатывает, когда объект читается, сеттер – когда значение присваивается"
      },
      {
        "question": "ПРОВЕРИТЬ ТИП",
        "answer": "typeof(x) возвращает тип данных аргумента"
      },
      {
        "question": "ПРОВЕРИТЬ ЧТО МАССИВ",
        "answer": "Array.isArray()"
      },
      {
        "question": "ПРОВЕРИТЬ ЧТО NAN",
        "answer": "Array.isNaN()"
      },
      {
        "question": "ОПЕРАТОРЫ",
        "answer": "Сравнение,Присваивание,Арифметические,Тернарный,Логический"
      },
      {
        "question": "ЛОГИЧЕСКИЕ ОПЕРАТОРЫ",
        "answer": "|| (ИЛИ), && (И) и ! (НЕ), ?? (Оператор нулевого слияния) a || b если один из a,b = true вернёт true \n"
      },
      {
        "question": "ТЕРНАРНЫЙ ОПЕРАТОР",
        "answer": "оператор в JavaScript, принимающий три операнда: условие, за которым следует знак вопроса (?), затем выражение, которое выполняется, если условие истинно, сопровождается двоеточием (:)  \nи наконец выражение, которое выполняется, если условие ложно.\n"
      },
      {
        "question": "двойное == и тройное === сравнение",
        "answer": "первый сравнивает значения после их преобразования к одному типу, а второй — без приведения \n(undefined==null=true) ('0'==false=true) (false=='',[]=true)  (false=={}=false) (''==0,[]=true) (''=={}=false) (0==[]=true) (0=={},null=false)\n"
      },
      {
        "question": "ЛОЖНЫЕ ЗНАЧЕНИЯ",
        "answer": "false,Number : 0 И -0, \"\" '',undefined,null,nan,bigint(0) ЕСЛИ ДЛИНА СТРОКИ 0"
      },
      {
        "question": "API",
        "answer": "это программный интерфейс для общения компонентов программы друг с другом\n"
      },
      {
        "question": "ПРОТОКОЛЫ API",
        "answer": "REST RPC"
      },
      {
        "question": "REST",
        "answer": "архитектурный стиль взаимодействия компонентов распределённого приложения  приложения в сети с использованием http протокола, в качестве ответа выдаётся веб\n сервер выдаёт формат данных json или ixm"
      },
      {
        "question": "ДЕКОМПОЗИЦИЯ, ДЕСТРУКТУРИЗАЦИЯ",
        "answer": "это синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.  let {name, email} = user; user исходный объект"
      },
      {
        "question": "SPREED-ОПЕРАТОР",
        "answer": "это три точки перед именем переменной (или константы) Он раскладывает соответствующий объект внутри нового объекта. С его помощью можно получить только копию, он не может изменять существующие объекты."
      },
      {
        "question": "РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ",
        "answer": "это шаблоны, используемые для сопоставления последовательностей символов в строках. применяется к примеру в match, replace, search\n"
      }
    ]
  },
  {
    "tag": "typescript",
    "list": [
      {
        "question": "typescript это",
        "answer": "TypeScript представляет язык программирования на основе JavaScript, компилируемый язык, так же он реализует концепций ооп и наследование, полиморфизм, инкапсуляция и модификаторы доступа и так далее, упрощает написание сложного кода\n"
      },
      {
        "question": "ДЕКОРАТОРЫ",
        "answer": "инструмент позволяющий добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода (функция, которую надо добавить перед классом свойством или методом со знаком @) применяются к классам\n"
      },
      {
        "question": "МОДИФИКАТОРЫ ДОСТУПА",
        "answer": "public\n\t\t\tprotected определяет поля и методы, которые из вне класса видны только в классах-наследниках:\n\t\t\tprivate, то к ним нельзя будет обратиться извне при создании объекта данного класса.\n"
      },
      {
        "question": "УТИНАЯ ТИПИЗАЦИЯ",
        "answer": "определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов\n"
      },
      {
        "question": "ТИПЫ",
        "answer": "type Login = string;const login:login = 'admin"
      },
      {
        "question": "INTERFACE",
        "answer": "interface rect {readonly id: string color?: string} readonly ? означает не обязательный const rect1: Rect = {id: '1234',color: 'black'}\n"
      },
      {
        "question": "ИНТЕРФЕЙС/ТИП - ОТЛИЧИЕ",
        "answer": "Типы являются более предпочтительным вариантом, так как вы можете заменить интерфейсы типами, но не наоборот. Для использования продвинутой функциональности TypeScript - mapped типов, объединения типов и условных типов \nинтерфейсы не подойдут."
      },
      {
        "question": "ENUM",
        "answer": "вспомогательная сущность для структурирования однотипного кода enum Mem {sim,sta,pre} const mem = Mem.sta\n"
      },
      {
        "question": "READONLY",
        "answer": "означает только для чтения"
      },
      {
        "question": "GENERICS ТИПЫ",
        "answer": "параметр-тип T, используется указывая функций что она будет работать с разными типами данных fun revers <T>(arrray:T[]): T[]\n"
      }
    ]
  },
  {
    "tag": "Функций и события",
    "list": [
      {
        "question": "FUNCTION",
        "answer": "это объект, которым можно манипулировать, передать параметры,  функция может что то возвращать,используются как бы для инкапсуляций логики,нупо сути и является строительным инструментом для обособления некого функционала \n"
      },
      {
        "question": "FUNCTION EXPRESSION",
        "answer": "объявление функции в контексте какого-либо выражения, например присваивания, к примеру в map, данная функция должна что то вернуть помещается в переменную\n"
      },
      {
        "question": "FUNCTION DECLARATION\n",
        "answer": "можем использовать в любой момент(имеет имя) которое служит в качестве переменной\n"
      },
      {
        "question": "КОНТЕКСТ",
        "answer": "если функция стрелочная то берётся из окружения так как не имеет своего если обычная то берёт от туда от куда была вызвана, контекст может быть своим либо переданным через call aplay, bind то же может изменить контекст но только 1 раз\n"
      },
      {
        "question": "КОНТЕКСТ И ОБЛАСТЬ ВИДИМОСТИ ОТЛИЧИЯ",
        "answer": "область видимости относится к переменным а контекст относится к функций к тому что оперирует данными,и они применяются по разному\n"
      },
      {
        "question": "ЧИСТАЯ ФУНКЦИЯ",
        "answer": "это функция которая выдаёт нам ожидаемый результат"
      },
      {
        "question": "АНОНИМНАЯ ФУНКЦИЯ",
        "answer": "часто используются для выполнения какого-то кода в коллбэках, где в целом не нужно создавать отдельную именную функцию под это действие"
      },
      {
        "question": "EVAL",
        "answer": "опасная функция, которая позволяет создать код на лету и выполнить его, это делает код не безопастным, так как мы можем подменить код и он выполнится, по сути это  код на который могут влиять злоумышленники,\n и который выполнится на правах нашей строницы"
      },
      {
        "question": "ЗАМЫКАНИЕ JS",
        "answer": "функция внутри функций, это способность функций,  запоминать ссылки на переменные и параметры, на своём уровне видимости, примменение когда надо переменную сделать приватной и не доступной из вне кроме как через функцию\n"
      },
      {
        "question": "EVENT",
        "answer": "объект который содержит свойства, описывающие некое событие."
      },
      {
        "question": "THIS",
        "answer": "это переменная в функции, ссылка на объект который вызывает эту функцию или текущий элемент, до которого дошло всплытие и на нём сейчас выполняется обработчик.\n"
      },
      {
        "question": "SCOPE",
        "answer": "это внутреннее скрытое свойство функции, которое она получает во время вызова,  обратится можно через THIZ\n"
      },
      {
        "question": "ЧТО БЫ ОСТАНОВИТЬ SETTIMEOUT",
        "answer": "clearTimeout"
      },
      {
        "question": "МЕТОД CALL",
        "answer": "позволяет вызвать функцию с заданным контекстом. Первым параметром метода следует указывать контекст функции, а остальными параметрами - параметры функции. fun.call(thisArg[, arg1[, arg2[, ...]]])\n"
      },
      {
        "question": "МЕТОД APPLAY",
        "answer": "то же самое но только ВТОРОЙ ПАРАМЕТР ОБЯЗАТЕЛЬНО МАССИВ fun.apply(thisArg, [argsArray])\n"
      },
      {
        "question": "МЕТОД BIND ОБЪЕКТ",
        "answer": "не вызывает а возвращает новую функцию  fun.bind(thisArg[, arg1[, arg2[, ...]]])\n"
      },
      {
        "question": "ОБРАБОТЧИКИ СОБЫТИИ JS",
        "answer": "click,submit,keydown,keyup и подобные"
      },
      {
        "question": "ВСПЛЫТИЕ, ПОГРУЖЕНИЕ",
        "answer": "ВСПЛЫТИЕ Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.\n\t\t\tПОГРУЖЕНИЕ событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.\n\t\t\tДля остановки всплытия нужно вызвать метод event. stopPropagation()\n"
      },
      {
        "question": "ASSING",
        "answer": "функция для копирования объектов, и избавления от ссылочной зависимости, но если внутри объекта будет ещё объект то ссылка на него сохраняется\n"
      },
      {
        "question": "ДЕЛЕГИРОВАНИЕ",
        "answer": "Вместо прикрепления обработчиков событий прямо к кнопкам, мы делегируем отслеживание этого события родительскому элементу <div id=\"buttons\">. Когда нажимается кнопка, обработчик, назначенный родительскому элементу ловит\n всплывающее событие затем через event.target проверяем на какой кнопке произошёл клик\n"
      },
      {
        "question": "REFLOW",
        "answer": "Пересчёт (Reflow) происходит, когда браузер должен снова обработать и отрисовать часть или всю веб-страницу, например, после изменения размера какого-нибудь блока или изменения его позиции на интерактивном сайте.\n"
      },
      {
        "question": "FEATURE DETECTION",
        "answer": "определение возможностей браузера"
      },
      {
        "question": "INTERFERENCE",
        "answer": "inference определяет  возможные способности браузера"
      },
      {
        "question": "USER AGENT",
        "answer": "User Agent определяет тип браузера"
      },
      {
        "question": "Проверить на целое число",
        "answer": "делим на 1 и проверяем остаток console.log(5 % 1) = thue"
      },
      {
        "question": "IIEF",
        "answer": "Функций моментального вызова"
      }
    ]
  },
  {
    "tag": "Асинхронность",
    "list": [
      {
        "question": "ПРОМИСЫ",
        "answer": "объект использующийся для отложенных и асинхронных вычислений. Используется когда надо что бы одна часть кода выполнялась после другой к примеру при работе с сервером, имеет состояния Ожидающий выполенный отклонённый"
      },
      {
        "question": "ПРОМИСЫ СТАТИ-КИЕ МЕТОДЫ",
        "answer": ".all .allSettled Полифил .race .reject  .resolve "
      },
      {
        "question": "МЕТОД PROMISE.ALL",
        "answer": "возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента, или отклонено любое из переданных промисов.\n"
      },
      {
        "question": "МЕТОД PROMISE.ALLSETTLED()",
        "answer": "возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.\n"
      },
      {
        "question": "PROMISE.RESOLVE(VALUE)",
        "answer": "возвращает Promise выполненный с переданным значением"
      },
      {
        "question": "PROMISE.REJECT",
        "answer": "возвращает Promise который был отклонён"
      },
      {
        "question": "PROMISE.RACE(ITERABLE)",
        "answer": "возвращает выполненный или отклонённый промис, в зависимости от того, с каким результатом завершится первый из переданных промисов, со значением или причиной\n отклонения этого промиса."
      },
      {
        "question": "PROMISE.THEN",
        "answer": "Универсальный метод для навешивания обработчиков"
      },
      {
        "question": "PROMISE.CATCH",
        "answer": "бработчик только на ошибку, вместо .then"
      },
      {
        "question": "ASYNG/AWAIT",
        "answer": "специальный синатксис, функция помеченная asyng возвращаемый результат оборачивает как промис и внутри мы можем использовать await\n"
      },
      {
        "question": "РАЗНИЦА МЕЖДУ ПРОМИС И ASYNG/AVAYT",
        "answer": "более лакончное написание, отсуствие вложнности"
      },
      {
        "question": "ПРОМИСЫ СТАТУСЫ",
        "answer": "pending ожидание,fulfilled исполнено, rejected отклонено, 4 статус действия окончены"
      }
    ]
  },
  {
    "tag": "ES 6",
    "list": [
      {
        "question": "TEMPLATE LITERALS, ШАБЛОННЫЕ ЛИТЕРАЛЫ",
        "answer": "это кривые ковычки `` позволяющие вставлять js в код html  ` ${ X-test }  `"
      },
      {
        "question": "НАСЛЕДОВАНИЕ EXTENDS",
        "answer": "означает - он получает все из своего родителя"
      },
      {
        "question": "ES 6 CLASS это",
        "answer": "это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы)\n"
      },
      {
        "question": "ИНТЕРФЕЙС interface - это",
        "answer": "определяет свойства и методы, которые объект должен реализовать. то есть это определение кастомного типа данных, но без реализации."
      },
      {
        "question": "IMPLEMENTS",
        "answer": "в этом случае почти как реализация интерфейса. Детский объект может притворяться, что он является родителем. но он не получает никакой реализации.\n"
      },
      {
        "question": "АБСТРАКТНЫЙ КЛАСС",
        "answer": "они не компилируются а используются в основном для наследования от них в процессе разработки, в них присутствуют обстрактные методы\n"
      },
      {
        "question": "IMPORT/EXPORT MODULE",
        "answer": "используются на этапе разработки и в конце всё сливается в единый файл байдинг,применённый импорт не дублируется и если мы импортировали несколько раз одно и то же то применится оно 1 раз\n"
      },
      {
        "question": "IMPORT ОСОБЕННОСТЬ",
        "answer": "если импортим (объект) то можем поменять его во всех модулях применив изменение только в одном месте так как объекты ссылочные а если примитив (переменная) то нет\n"
      },
      {
        "question": "СТАТИЧЕСКИЙ КЛАСС ",
        "answer": "класс, состоящий исключительно из статических методов и свойств.\n"
      }
    ]
  },
  {
    "tag": "ООП",
    "list": [
      {
        "question": "ПРИНЦИПЫ ООП",
        "answer": "Наследование Инкапсуляция Полиморфизм"
      },
      {
        "question": "ООП НАСЛЕДОВАНИЕ ",
        "answer": "концепция, согласно которой абстрактный тип данных может наследовать данные и функциональность реализуется через extends "
      },
      {
        "question": "АБСТРАКЦИЯ",
        "answer": "означает выделение главных, наиболее значимых характеристик и скрытие не особо значимых \n"
      },
      {
        "question": "ИНКАПСУЛЯЦИЯ ",
        "answer": "размещение в одном компоненте данных и методов, которые с ними работают, так что доступ к этим данным ограничен извне\n"
      },
      {
        "question": "ПОЛИМОРФИЗМ ",
        "answer": "способность функции обрабатывать данные разных типов"
      },
      {
        "question": "SOLID ",
        "answer": "это аббревиатура пяти основных принципов проектирования в объектно‑ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion.\n"
      },
      {
        "question": "1) SINGLE RESPONSIBILITY\n",
        "answer": "принцип единственной ответственности\n"
      },
      {
        "question": "2) OPEN-CLOSED\n",
        "answer": "принцип открытости / закрытости\n"
      },
      {
        "question": "3) LISKOV SUBSTITUTION\n",
        "answer": "принцип подстановки Барбары Лисков\n"
      },
      {
        "question": "4) INTERFACE SEGREGATION\n",
        "answer": "принцип разделения интерфейса\n"
      },
      {
        "question": "5) DEPENDENCY INVERSION\n",
        "answer": "принцип инверсии зависимостей суть которого состоит в том, что классы должны зависеть от абстракций, а не от конкретных деталей\n"
      },
      {
        "question": "DEPENDENCY INJECTION\n",
        "answer": "Концепция Dependency Injection состоит в том, чтобы перенести ответственность за создание экземпляра объекта из тела метода за пределы класса и передать уже созданный экземпляр объекта обратно.\n"
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "tag": "VUE 3",
    "list": [
      {
        "question": "LIFECYCLE HOOKS VUE3\n",
        "answer": "onMounted onUpdated onUnmounted onActivated onDeactivated\n"
      },
      {
        "question": "ЖИЗНЕННЫЙ ЦИКЛ",
        "answer": "INIT(events&lifecycle) BeforeCreate -> INIT(injections&reactivite) Created -> beforeMount CREATED APP mounted -> MOUNTED beforeUnmount -> UNMOUNT -> unmounted\n"
      },
      {
        "question": "РЕАКТИВНОСТЬ VUE",
        "answer": "переменные объявленные в коде просто отображаются в шаблоне. При этом при изменение значения переменных в коде они автоматически будут обновляется в шаблоне. Такой механизм и называется реактивность Vue.js\n"
      },
      {
        "question": "ВЫЧИСЛЯЕМЫЕ СВОЙСТВА",
        "answer": "они представляют из себя функций определяемые в поле COMPUTED которые возвращают результат каких то вычислений x-test: function () { return a+b} но отличие от обычных функций в том что они кешируются и изменяются когда меняется переменная\n в свойстве\n"
      },
      {
        "question": "ОТСЛЕЖИВАЕМЫЕ СВОЙСТВА\n",
        "answer": "объявляются в WATCH и явсляются функциями которые именуются так же как переменная за которой надо следить\n"
      },
      {
        "question": "ДИРЕКТИВЫ",
        "answer": "v-if,v-else,v-else-if,v-show,v-for,v-model,v-on,v-bind,v-text,v-slot,v-pre\n"
      },
      {
        "question": "V-IF /  V-SHOW РАЗНИЦА\n",
        "answer": "в том что SHOW скрывает но не удаляет а IF удаляет из DOM\n"
      },
      {
        "question": "V-KEY: X-TEST\n",
        "answer": "Добавление уникального ключа компоненту что бы при перерисовке дома он не вызывал свой методы и свойства если в нём дом не менялся\n"
      },
      {
        "question": "Методы\n",
        "answer": "на примере функций они будут производить вычисления при любом обращений\n"
      },
      {
        "question": "РОДИТЕЛЬ ---> СЫН\n",
        "answer": "props,store provide позволяет игнорировать вложенность, vueX pinia плагин позволяющий так же передавать и подписыватся на изменения \n"
      },
      {
        "question": "СЫН ---> РОДИТЕЛЬ\n",
        "answer": "$emit, vueX pinia"
      },
      {
        "question": "$EMIT ЭТО\n",
        "answer": "событие позволяющее передать данные из дочернего компонента в родительский с помощью подписки в родительском\n"
      },
      {
        "question": "COMPUTED СВОЙСТВО\n",
        "answer": "вычисляемые свойства, ещё они кешируются будут производить вычисления только при изменений данных которые влият на результат\n"
      },
      {
        "question": "WATCH СВОЙСТВО\n",
        "answer": "для отслеживания переменной, и при изменении этой переменной он позволяет нам запускать функцию, чтобы мы могли выполнять динамическое взаимодействие.\n"
      },
      {
        "question": "ИНТЕРПОЛЯЦИЯ\n",
        "answer": "привязка к шаблону для вывода данных в него через {{x-test}}\n"
      },
      {
        "question": "МИКСИНЫ\n",
        "answer": "переиспользуемый js код который может содержать теже методы что и компонет, подключаем через mixins:[x-test] в export default\n"
      },
      {
        "question": "СЛУШАТЕЛЬ СОБЫТИЯ\n",
        "answer": "v-on:click=\"x-test\" или сокращённый вариант @click=\"x-test\"\n"
      },
      {
        "question": "МОДИФИКАТОРЫ СОБЫТИЙ\n",
        "answer": "@click.stop = stopPropagation, @click.prevent = preventdefault, .right , .alt , .capture итд \n"
      },
      {
        "question": "МОДИФИКАТОРЫ У V-MODEL\n",
        "answer": "v-model.number преобразовывает значение к числу, lazy меняет поведение на on-change, trim удаляет пробелы\n"
      },
      {
        "question": "ГЛОБАЛЬНАЯ РЕГИСТРАЦИЯ\n",
        "answer": "компоненты регестрируются через app.component('x-test',Component) в main.js\n"
      },
      {
        "question": "СМЕНА КЛАССА CSS\n",
        "answer": "data(return{toggle:false}) <button @click=\"toggle = !toggle\"> <div :class=\"{x-test:toggle}\">\n"
      },
      {
        "question": "REF\n",
        "answer": "даёт доступ к DOM элементам <input ref=\"x-test\"> methods:{getRef(){console.log(this.$refs.x-test)}}\n"
      },
      {
        "question": "навязывание реактивности 3\n",
        "answer": "Ref и reactive разница ref возвращает объект с value, reactive возвращает реактивный объект\n"
      },
      {
        "question": "REF\n",
        "answer": "даёт доступ к DOM элементам <input ref=\"x-test\"> methods:{getRef(){console.log(this.$refs.x-test)}}\n"
      }
    ]
  }
]